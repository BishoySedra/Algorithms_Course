using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Problem
{
    public static class PROBLEM_CLASS
    {
        #region YOUR CODE IS HERE
        //Your Code is Here:
        //==================
        /// <summary>
        /// Ali Baba decides to go on a skating travel in the alpine mountain. He has stolen a pair of skis and a trail map listing 
        /// the mountain’s surfaces and slopes (n in total), and he wants to ski from surface S to surface T where a treasure is exists. 
        /// </summary>
        /// <param name="vertices">array of surfaces and their elevations </param>
        /// <param name="edges">array of trails and their lengths </param>
        /// <param name="startVertex">name of the start surface to begin from it</param>
        /// <returns>the minimum valid distance from source “S” to target “T”.</returns>
        public static int answer = int.MaxValue;
        public static string target = "T";
        public static Dictionary<string, List<Tuple<string, int>>> graph = new Dictionary<string, List<Tuple<string, int>>>();
        public static Dictionary<KeyValuePair<string, string>, int> weights = new Dictionary<KeyValuePair<string, string>, int>();
        public static Dictionary<string, bool> visited = new Dictionary<string, bool>();

        static void DFS(string node, int distance)
        {
            if (node == target)
            {
                answer = Math.Min(answer, distance);
                return;
            }

            visited[node] = true; // Mark the current node as visited

            foreach (Tuple<string,int> child in graph[node])
            {
                if (!visited[child.Item1]) // Check if the child node is not visited
                {
                    DFS(child.Item1, distance + child.Item2);
                }
            }

            visited[node] = false;

        }

        public static int RequiredFunction(Dictionary<string, int> vertices, Dictionary<KeyValuePair<string, string>, int> edges, string startVertex)
        {
            // clear the dictionary
            graph.Clear();
            weights.Clear();
            visited.Clear();
            answer = int.MaxValue;

            int from, to, weight;
            string from_string, to_string;
            // iterate over the vertices and initialize the graph and visited dictionary
            foreach (KeyValuePair<string, int> vertex in vertices)
            {
                graph[vertex.Key] = new List<Tuple<string, int>>();
                visited[vertex.Key] = false;
            }

            // ctrl + k + d
            // construct the graph
            foreach (KeyValuePair<KeyValuePair<string, string>, int> edge in edges)
            {
                from = vertices[edge.Key.Key];
                from_string = edge.Key.Key;

                to = vertices[edge.Key.Value];
                to_string = edge.Key.Value;
                weight = edge.Value;

                if (from > to)
                {
                    graph[from_string].Add(new Tuple<string, int>(to_string, weight));
                }
                else
                {
                    graph[to_string].Add(new Tuple<string, int>(from_string, weight));
                }
            }

            // Do DFS
            DFS(startVertex, 0);

            return answer;
            // REMOVE THIS LINE BEFORE START CODING
            // throw new NotImplementedException();
        }
        #endregion
    }
}
