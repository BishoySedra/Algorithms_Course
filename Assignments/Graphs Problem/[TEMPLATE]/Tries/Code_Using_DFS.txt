using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Problem
{
    public static class PROBLEM_CLASS
    {
        #region YOUR CODE IS HERE
        //Your Code is Here:
        //==================
        /// <summary>
        /// Ali Baba decides to go on a skating travel in the alpine mountain. He has stolen a pair of skis and a trail map listing 
        /// the mountain’s surfaces and slopes (n in total), and he wants to ski from surface S to surface T where a treasure is exists. 
        /// </summary>
        /// <param name="vertices">array of surfaces and their elevations </param>
        /// <param name="edges">array of trails and their lengths </param>
        /// <param name="startVertex">name of the start surface to begin from it</param>
        /// <returns>the minimum valid distance from source “S” to target “T”.</returns>
        public static int answer = int.MaxValue;
        public static int target;
        public static Dictionary<int, List<int>> graph = new Dictionary<int, List<int>>();
        public static Dictionary<KeyValuePair<int, int>, int> weights = new Dictionary<KeyValuePair<int, int>, int>();
        public static Dictionary<int, bool> visited = new Dictionary<int, bool>(); // Keep track of visited nodes

        static void DFS(int node, int distance)
        {
            if (node == target)
            {
                answer = Math.Min(answer, distance);
            }

            visited[node] = true; // Mark the current node as visited

            if (graph.ContainsKey(node))
            {
                foreach (var child in graph[node])
                {
                    if (!visited.ContainsKey(child)) // Check if the child node is not visited
                    {
                        DFS(child, distance + weights[new KeyValuePair<int, int>(node, child)]);
                    }
                }
            }
        }

        public static int RequiredFunction(Dictionary<string, int> vertices, Dictionary<KeyValuePair<string, string>, int> edges, string startVertex)
        {
            int start = vertices[startVertex];
            target = vertices["T"];

            foreach (var edge in edges)
            {
                var from = vertices[edge.Key.Key];
                var to = vertices[edge.Key.Value];
                var weight = edge.Value;

                if (from > to)
                {
                    if (!graph.ContainsKey(from))
                    {
                        graph[from] = new List<int>();
                    }

                    graph[from].Add(to);
                }
                else
                {
                    if (!graph.ContainsKey(to))
                    {
                        graph[to] = new List<int>();
                    }

                    graph[to].Add(from);
                }

                weights[new KeyValuePair<int, int>(to, from)] = weight;
                weights[new KeyValuePair<int, int>(from, to)] = weight;
            }

            // Do DFS
            DFS(start, 0);

            return answer;
            // REMOVE THIS LINE BEFORE START CODING
            // throw new NotImplementedException();
        }
        #endregion
    }
}
